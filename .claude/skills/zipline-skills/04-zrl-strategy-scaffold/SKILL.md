---
name: zrl-strategy-scaffold
description: This skill should be used when creating new Zipline trading strategies from scratch. It provides professional boilerplate templates, coding standards, and structural patterns for building maintainable, testable algorithmic trading strategies.
---

# Zipline Strategy Scaffold

Generate professional, production-ready strategy templates for Zipline-Reloaded.

## Purpose

Accelerate strategy development by providing standardized templates that follow best practices for code organization, parameter management, logging, and testability.

## When to Use

- Starting a new trading strategy
- Refactoring existing strategies to production quality
- Learning proper Zipline structure
- Creating strategy templates for teams

## Strategy Architecture

```
strategy_name/
├── strategy.py          # Main algorithm file
├── config.py            # Parameters and configuration
├── signals.py           # Signal generation logic
├── execution.py         # Order execution logic
├── risk.py              # Risk management
├── utils.py             # Helper functions
├── tests/
│   ├── test_signals.py
│   └── test_backtest.py
└── notebooks/
    └── analysis.ipynb
```

## Core Template

Execute `scripts/scaffold.py` to generate a new strategy:

```bash
python scripts/scaffold.py \
    --name momentum_strategy \
    --type pipeline \
    --output ./strategies/
```

### Generated strategy.py

```python
"""
Momentum Strategy
Generated by zrl-strategy-scaffold
"""
from zipline.api import (
    attach_pipeline, pipeline_output,
    order_target_percent, schedule_function,
    date_rules, time_rules, record, symbol
)
from zipline.pipeline import Pipeline

from config import StrategyConfig
from signals import SignalGenerator
from execution import ExecutionEngine
from risk import RiskManager


def initialize(context):
    """Initialize strategy state and configuration."""
    # Load configuration
    context.config = StrategyConfig()
    
    # Initialize components
    context.signals = SignalGenerator(context.config)
    context.execution = ExecutionEngine(context.config)
    context.risk = RiskManager(context.config)
    
    # Attach pipeline if using
    if context.config.use_pipeline:
        attach_pipeline(make_pipeline(context.config), 'main')
    
    # Schedule rebalancing
    schedule_function(
        rebalance,
        date_rule=context.config.rebalance_date_rule,
        time_rule=context.config.rebalance_time_rule
    )
    
    # Schedule end-of-day
    schedule_function(
        end_of_day,
        date_rule=date_rules.every_day(),
        time_rule=time_rules.market_close(minutes=15)
    )
    
    context.initialized = True


def before_trading_start(context, data):
    """Daily pre-market preparation."""
    if context.config.use_pipeline:
        context.pipeline_output = pipeline_output('main')
        context.signals.update(context.pipeline_output)


def rebalance(context, data):
    """Execute rebalancing logic."""
    # Get target weights from signals
    target_weights = context.signals.get_target_weights(context, data)
    
    # Apply risk constraints
    target_weights = context.risk.apply_constraints(target_weights, context)
    
    # Execute orders
    context.execution.execute_target_weights(target_weights, context, data)


def handle_data(context, data):
    """Process each bar (optional for scheduled strategies)."""
    # Record metrics
    record(
        portfolio_value=context.portfolio.portfolio_value,
        positions=len(context.portfolio.positions),
        cash=context.portfolio.cash
    )


def end_of_day(context, data):
    """End of day processing."""
    context.risk.end_of_day_check(context, data)


def make_pipeline(config):
    """Build the pipeline."""
    from zipline.pipeline.factors import Returns, AverageDollarVolume
    
    returns = Returns(window_length=config.momentum_window)
    volume = AverageDollarVolume(window_length=config.volume_window)
    
    universe = volume.top(config.universe_size)
    
    return Pipeline(
        columns={
            'returns': returns,
            'volume': volume,
        },
        screen=universe
    )


def analyze(context, perf):
    """Post-backtest analysis."""
    from analysis import generate_report
    generate_report(perf, context.config)
```

## Template Types

### Type: Simple (handle_data)

For bar-by-bar strategies:

```bash
python scripts/scaffold.py --name my_strategy --type simple
```

### Type: Pipeline (daily rebalance)

For factor-based strategies:

```bash
python scripts/scaffold.py --name my_strategy --type pipeline
```

### Type: Scheduled (custom scheduling)

For complex timing requirements:

```bash
python scripts/scaffold.py --name my_strategy --type scheduled
```

### Type: Multi-Asset

For portfolio strategies:

```bash
python scripts/scaffold.py --name my_strategy --type multi_asset
```

## Configuration Pattern

### config.py Template

```python
from dataclasses import dataclass, field
from typing import List
from zipline.api import date_rules, time_rules

@dataclass
class StrategyConfig:
    """Strategy configuration with defaults."""
    
    # Strategy identification
    name: str = "my_strategy"
    version: str = "1.0.0"
    
    # Universe
    universe_size: int = 500
    min_price: float = 5.0
    min_volume: float = 1_000_000
    
    # Signal parameters
    momentum_window: int = 20
    volume_window: int = 20
    
    # Position sizing
    max_position_size: float = 0.05  # 5% max per position
    max_gross_exposure: float = 1.0
    max_leverage: float = 1.0
    
    # Execution
    use_pipeline: bool = True
    rebalance_date_rule: object = field(default_factory=lambda: date_rules.week_start())
    rebalance_time_rule: object = field(default_factory=lambda: time_rules.market_open(hours=1))
    
    # Risk
    max_drawdown: float = 0.20  # 20% max drawdown
    stop_loss: float = 0.10    # 10% stop loss per position
    
    def validate(self):
        """Validate configuration."""
        assert 0 < self.max_position_size <= 1.0
        assert 0 < self.max_leverage <= 2.0
        assert self.universe_size > 0
        return True
```

## Coding Standards

### Naming Conventions

```python
# Classes: PascalCase
class MomentumStrategy:
    pass

# Functions/methods: snake_case
def calculate_signals(data):
    pass

# Constants: UPPER_SNAKE_CASE
MAX_POSITION_SIZE = 0.05

# Context variables: snake_case
context.current_positions = {}
```

### Documentation

```python
def calculate_momentum(prices: pd.Series, window: int) -> float:
    """
    Calculate momentum signal.
    
    Parameters
    ----------
    prices : pd.Series
        Historical price series
    window : int
        Lookback window in days
    
    Returns
    -------
    float
        Momentum score (-1 to 1)
    
    Examples
    --------
    >>> momentum = calculate_momentum(prices, window=20)
    """
    return (prices.iloc[-1] / prices.iloc[0]) - 1
```

### Error Handling

```python
def safe_order(context, data, asset, target_pct):
    """Place order with safety checks."""
    try:
        if not data.can_trade(asset):
            log.warn(f"Cannot trade {asset}")
            return None
        
        return order_target_percent(asset, target_pct)
    except Exception as e:
        log.error(f"Order failed for {asset}: {e}")
        return None
```

## Script Reference

### scaffold.py

Generate new strategy structure:

```bash
python scripts/scaffold.py \
    --name strategy_name \
    --type pipeline \
    --output /path/to/strategies \
    --include-tests \
    --include-notebooks
```

### validate_strategy.py

Validate strategy structure and syntax:

```bash
python scripts/validate_strategy.py /path/to/strategy
```

## Testing Pattern

### tests/test_backtest.py

```python
import pytest
from zipline import run_algorithm

def test_strategy_runs():
    """Verify strategy executes without errors."""
    from strategy import initialize, handle_data
    
    result = run_algorithm(
        start=pd.Timestamp('2020-01-01', tz='utc'),
        end=pd.Timestamp('2020-03-31', tz='utc'),
        initialize=initialize,
        handle_data=handle_data,
        capital_base=100000,
        bundle='test-bundle'
    )
    
    assert result is not None
    assert len(result) > 0
    assert result['portfolio_value'].iloc[-1] > 0
```

## References

See `references/coding_standards.md` for complete style guide.
See `assets/templates/` for additional template files.
