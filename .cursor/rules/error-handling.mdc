---
description: Error handling patterns - exception types, logging, graceful degradation
globs: **/*.py
alwaysApply: true
---

# Error Handling Standards

## Purpose
Define consistent error handling patterns, exception types, logging practices, and graceful degradation strategies across the codebase.

## Exception Types

### Custom Exception Hierarchy
Use project-specific exceptions for domain errors.

```python
# ✅ GOOD - Use custom exceptions
from lib.paths import ProjectRootNotFoundError

try:
    root = get_project_root()
except ProjectRootNotFoundError as e:
    logger.error(f"Project root not found: {e}")
    # Handle gracefully

# ❌ BAD - Generic exceptions
try:
    root = get_project_root()
except Exception as e:  # Too generic!
    logger.error(f"Error: {e}")
```

### Standard Exception Types

```python
# ✅ GOOD - Defined in lib/paths.py
class ProjectRootNotFoundError(Exception):
    """Raised when project root cannot be determined."""
    pass

# ✅ GOOD - Validation errors
class ValidationError(Exception):
    """Raised when validation fails."""
    pass

# ❌ BAD - Using built-in exceptions for domain errors
raise FileNotFoundError("Project root not found")  # Use ProjectRootNotFoundError!
```

## Error Logging

### Use Centralized Logging
Always use `lib/logging/` modules for error logging.

```python
# ✅ GOOD - Use project logging
from lib.logging.config import configure_logging, get_logger

configure_logging()
logger = get_logger(__name__)

try:
    result = risky_operation()
except Exception as e:
    logger.error(f"Operation failed: {e}", exc_info=True)
    raise

# ❌ BAD - Print statements or basic logging
try:
    result = risky_operation()
except Exception as e:
    print(f"Error: {e}")  # Don't use print!
    logging.error(e)  # Not configured properly!
```

### Log Levels

```python
# ✅ GOOD - Appropriate log levels
logger.debug("Detailed debugging info")  # Development only
logger.info("Operation completed successfully")
logger.warning("Non-critical issue occurred")
logger.error("Operation failed", exc_info=True)
logger.critical("System cannot continue")

# ❌ BAD - Wrong log levels
logger.error("User logged in")  # Should be info!
logger.info("Database connection failed")  # Should be error!
```

### Structured Error Logging

```python
# ✅ GOOD - Structured error context
from lib.logging.context import LogContext

with LogContext(phase='backtest', strategy='btc_sma_cross'):
    try:
        run_backtest(config)
    except Exception as e:
        logger.error(
            "Backtest failed",
            exc_info=True,
            extra={'strategy': 'btc_sma_cross', 'config': config}
        )

# ❌ BAD - Unstructured error messages
try:
    run_backtest(config)
except Exception as e:
    logger.error(f"Error: {e}")  # Missing context!
```

## Graceful Degradation

### Fallback Patterns

```python
# ✅ GOOD - Graceful fallback
def load_config_with_fallback(config_path: Path) -> dict:
    try:
        return load_yaml(config_path)
    except FileNotFoundError:
        logger.warning(f"Config not found: {config_path}, using defaults")
        return get_default_config()
    except yaml.YAMLError as e:
        logger.error(f"Invalid YAML: {config_path}", exc_info=True)
        raise ValidationError(f"Config file invalid: {e}") from e

# ❌ BAD - Fail hard without fallback
def load_config(config_path: Path) -> dict:
    return load_yaml(config_path)  # Will crash if file missing!
```

### Validation with Clear Messages

```python
# ✅ GOOD - Clear validation errors
def validate_strategy_params(params: dict) -> None:
    required = ['symbol', 'fast_period', 'slow_period']
    missing = [key for key in required if key not in params]
    if missing:
        raise ValidationError(
            f"Missing required parameters: {', '.join(missing)}"
        )

# ❌ BAD - Cryptic validation
def validate_strategy_params(params: dict) -> None:
    if not all(k in params for k in ['symbol', 'fast_period', 'slow_period']):
        raise ValueError("Invalid")  # Not helpful!
```

## User-Facing Error Messages

### Clear, Actionable Messages

```python
# ✅ GOOD - User-friendly error message
try:
    strategy_path = resolve_strategy_path('btc_sma_cross')
except FileNotFoundError:
    raise FileNotFoundError(
        "Strategy 'btc_sma_cross' not found.\n"
        "Searched in: strategies/crypto/, strategies/forex/, strategies/equities/\n"
        "Create the strategy using: scripts/create_strategy.py"
    )

# ❌ BAD - Technical error message
try:
    strategy_path = resolve_strategy_path('btc_sma_cross')
except FileNotFoundError as e:
    raise  # Just re-raise - not helpful to user!
```

## Exception Chaining

### Preserve Exception Context

```python
# ✅ GOOD - Chain exceptions
try:
    data = load_bundle_data(bundle_name)
except FileNotFoundError as e:
    raise BundleNotFoundError(
        f"Bundle '{bundle_name}' not found"
    ) from e

# ❌ BAD - Lose exception context
try:
    data = load_bundle_data(bundle_name)
except FileNotFoundError:
    raise BundleNotFoundError(f"Bundle '{bundle_name}' not found")
    # Lost original exception context!
```

## Enforcement

- **Code Review**: Check exception types and messages
- **Logging Audit**: Verify all errors are logged
- **Exception Handling**: No bare `except:` clauses

## Related Agents

- `.claude/agents/maintainer.md` - Error handling patterns
- `.claude/agents/validator.md` - Validation errors
