---
description: Data validation patterns - DataValidator, ValidationResult, ValidationConfig, composite validation
globs: lib/validation/**/*.py,scripts/validate_csv_data.py
alwaysApply: false
---

# Data Validation Patterns

## Purpose
Define patterns for validating OHLCV data using `lib/validation/` modules, including DataValidator, ValidationResult, ValidationConfig, and composite validation.

## Data Validation

### Use DataValidator Class
Always use `lib.validation.DataValidator` for OHLCV data validation.

```python
# ✅ GOOD - Use DataValidator
from lib.validation import DataValidator, ValidationConfig

config = ValidationConfig.strict(timeframe='1d')
validator = DataValidator(config=config)
result = validator.validate(df, asset_name='AAPL')

if not result:
    print(result.summary())
    raise ValueError("Data validation failed")

# ❌ BAD - Manual validation
if df.isnull().any().any():
    raise ValueError("Null values found")  # Incomplete validation!
```

### Validation Configuration

```python
# ✅ GOOD - Use ValidationConfig
from lib.validation import ValidationConfig, DataValidator

# Strict validation
config = ValidationConfig.strict(timeframe='1d')
validator = DataValidator(config=config)

# Custom validation
config = ValidationConfig(
    timeframe='1h',
    strict_mode=True,
    asset_type='crypto',
    suggest_fixes=True
)
validator = DataValidator(config=config)

# ❌ BAD - No configuration
validator = DataValidator()  # Uses defaults, may not be appropriate!
```

## Validation Result Handling

### Check ValidationResult
Always check `ValidationResult` after validation.

```python
# ✅ GOOD - Check validation result
from lib.validation import DataValidator, ValidationConfig

validator = DataValidator(ValidationConfig(timeframe='1d'))
result = validator.validate(df, asset_name='AAPL')

if not result:
    # Handle errors
    for error in result.errors:
        print(f"Error: {error}")
    for warning in result.warnings:
        print(f"Warning: {warning}")
    raise ValueError("Validation failed")

# Check individual checks
for check in result.checks:
    if not check.passed:
        print(f"Check '{check.name}' failed: {check.message}")

# ❌ BAD - Ignore validation result
result = validator.validate(df)
# No check if validation passed!
```

### ValidationResult Methods

```python
# ✅ GOOD - Use ValidationResult methods
result = validator.validate(df, asset_name='AAPL')

# Check if valid
if result.is_valid:
    print("Validation passed")

# Get summary
summary = result.summary()
print(summary)

# Merge results
result1 = validator.validate(df1)
result2 = validator.validate(df2)
combined = result1.merge(result2)

# ❌ BAD - Access result attributes directly
if result.passed:  # Should use result.is_valid!
    pass
```

## Composite Validation

### Use CompositeValidator
Use `CompositeValidator` to chain multiple validators.

```python
# ✅ GOOD - Use CompositeValidator
from lib.validation import (
    DataValidator,
    BundleValidator,
    CompositeValidator,
    ValidationConfig
)

config = ValidationConfig(timeframe='1d')
composite = CompositeValidator([
    DataValidator(config=config),
    BundleValidator(config=config)
])

result = composite.validate(df, bundle_name='yahoo_crypto_daily')

# ❌ BAD - Manual validation chaining
result1 = validator1.validate(df)
result2 = validator2.validate(df)
# Manual merging - error-prone!
```

## Validation Config Patterns

### ValidationConfig Factory Methods

```python
# ✅ GOOD - Use factory methods
from lib.validation import ValidationConfig

# Strict mode
config = ValidationConfig.strict(timeframe='1d')

# Lenient mode
config = ValidationConfig.lenient(timeframe='1h')

# Custom config
config = ValidationConfig(
    timeframe='daily',
    strict_mode=False,
    asset_type='crypto',
    calendar_name='CRYPTO',
    suggest_fixes=True
)

# ❌ BAD - Always use defaults
config = ValidationConfig()  # May not match data type!
```

## Pre-Ingestion Validation

### Validate Before Ingestion
Always validate data before ingesting into bundles.

```python
# ✅ GOOD - Validate before ingestion
from lib.validation import validate_before_ingest

result = validate_before_ingest(
    df=df,
    asset_name='BTC-USD',
    timeframe='daily',
    asset_type='crypto',
    strict_mode=True
)

if not result:
    raise ValueError(f"Pre-ingestion validation failed: {result.summary()}")

# Now safe to ingest
ingest_bundle(...)

# ❌ BAD - Ingest without validation
ingest_bundle(source='yahoo', ...)  # May ingest invalid data!
```

## Validation Report Saving

### Save Validation Reports
Save validation reports for audit trail.

```python
# ✅ GOOD - Save validation report
from lib.validation import save_validation_report

result = validator.validate(df, asset_name='AAPL')
save_validation_report(
    result,
    output_path='validation_reports/aapl_validation.json',
    include_summary=True
)

# ❌ BAD - Don't save validation results
result = validator.validate(df)
# No audit trail!
```

## Enforcement

- **Code Review**: Verify validation before data operations
- **Result Checking**: Ensure ValidationResult is checked
- **Config Usage**: Verify appropriate ValidationConfig used
- **Report Saving**: Check validation reports saved for critical operations

## Related Agents

- `.claude/agents/validator.md` - Validation patterns
- `.claude/agents/data-ingestor.md` - Pre-ingestion validation
- `lib/validation/` - Validation module documentation
